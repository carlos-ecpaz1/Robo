#!/usr/bin/env python3
"""
Autonomous Pentest Robot v4.0 - INTERACTIVE & SMART
Vers√£o interativa com decis√µes baseadas em CMS detectado
"""

import subprocess
import json
import re
import os
import sys
from datetime import datetime
import time
import argparse

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

class PentestRobot:
    def __init__(self, target, output_dir=None, verbose=True, aggressive=False, interactive=True):
        self.target = target
        
        # Se output_dir n√£o foi especificado, usar nome do target
        if output_dir is None:
            # Limpar o target para nome de pasta v√°lido
            clean_target = target.replace('http://', '').replace('https://', '')
            clean_target = clean_target.replace('/', '_').replace(':', '_')
            clean_target = re.sub(r'[^\w\-_\.]', '_', clean_target)
            output_dir = f"scan_{clean_target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        self.output_dir = output_dir
        self.verbose = verbose
        self.aggressive = aggressive
        self.interactive = interactive  # Modo interativo
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # User-Agent customizado
        self.user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        
        # Estado do rob√¥
        self.discovered_ports = []
        self.web_services = []
        self.technologies = {}
        self.vulnerabilities = []
        self.directories = []
        self.findings = []
        self.users_found = []
        self.plugins_found = []
        self.cms_info = {}
        self.exploits_found = []  # NOVO: Lista de exploits
        self.nikto_executed = False  # NOVO: Flag para Nikto
        
        os.makedirs(self.output_dir, exist_ok=True)
        self.log_file = f"{self.output_dir}/robot_log.txt"
        
    def log(self, message, level="INFO"):
        """Logger"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        colors = {
            "INFO": Colors.CYAN,
            "SUCCESS": Colors.GREEN,
            "WARNING": Colors.YELLOW,
            "ERROR": Colors.RED,
            "DECISION": Colors.BLUE,
            "VULN": Colors.RED + Colors.BOLD,
            "EXPLOIT": Colors.RED + Colors.BOLD,
            "QUESTION": Colors.YELLOW + Colors.BOLD
        }
        
        color = colors.get(level, Colors.ENDC)
        
        if self.verbose:
            print(f"{color}[{timestamp}] [{level}] {message}{Colors.ENDC}")
        
        with open(self.log_file, 'a') as f:
            f.write(f"[{timestamp}] [{level}] {message}\n")
    
    def ask_user(self, question, default="y"):
        """Pergunta ao usu√°rio (modo interativo)"""
        if not self.interactive:
            return default == "y"
        
        self.log(question, "QUESTION")
        
        valid_responses = {
            'y': True, 'yes': True, 's': True, 'sim': True,
            'n': False, 'no': False, 'n√£o': False, 'nao': False
        }
        
        while True:
            try:
                response = input(f"{Colors.YELLOW}[?] {question} (y/n) [{default}]: {Colors.ENDC}").lower().strip()
                
                if not response:
                    response = default
                
                if response in valid_responses:
                    return valid_responses[response]
                else:
                    print(f"{Colors.RED}Por favor, responda 'y' ou 'n'{Colors.ENDC}")
            except KeyboardInterrupt:
                print(f"\n{Colors.RED}Opera√ß√£o cancelada{Colors.ENDC}")
                return False
    
    def run_command(self, command, description, timeout=300):
        """Executa comando"""
        self.log(f"Executando: {description}", "INFO")
        
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            return result.stdout, result.returncode
        except subprocess.TimeoutExpired:
            self.log(f"Timeout em: {description}", "WARNING")
            return None, -1
        except Exception as e:
            self.log(f"Erro em {description}: {str(e)}", "ERROR")
            return None, -1
    
    def check_tool(self, tool):
        """Verifica ferramenta"""
        result = subprocess.run(f"which {tool}", shell=True, capture_output=True)
        return result.returncode == 0
    
    def print_banner(self):
        """Banner"""
        banner = f"""
{Colors.CYAN}
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                          ‚ïë
‚ïë        ü§ñ AUTONOMOUS PENTEST ROBOT v4.0 ü§ñ              ‚ïë
‚ïë           INTERACTIVE & SMART WORKFLOW                   ‚ïë
‚ïë                                                          ‚ïë
‚ïë        Target: {self.target:<42} ‚ïë
‚ïë        Mode: {'INTERACTIVE' if self.interactive else 'AUTO':<47}‚ïë
‚ïë                                                          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
{Colors.ENDC}
"""
        print(banner)
        self.log("Rob√¥ v4.0 inicializado", "SUCCESS")
    
    # ===== FASE 1: PORT DISCOVERY =====
    
    def phase1_port_discovery(self):
        """Port discovery"""
        self.log("="*60, "INFO")
        self.log("FASE 1: DESCOBERTA DE PORTAS", "INFO")
        self.log("="*60, "INFO")
        
        if not self.check_tool("nmap"):
            self.log("Nmap n√£o encontrado!", "ERROR")
            return False
        
        output, code = self.run_command(
            f"nmap -sV -sC -T4 -F --open {self.target}",
            "Nmap Service Detection",
            timeout=300
        )
        
        if output:
            self.parse_nmap_output(output)
            
        if not self.discovered_ports:
            self.log("Tentando scan completo...", "DECISION")
            output, code = self.run_command(
                f"nmap -sV -p- -T4 --open {self.target}",
                "Nmap Full Scan",
                timeout=900
            )
            if output:
                self.parse_nmap_output(output)
        
        self.log(f"Portas descobertas: {len(self.discovered_ports)}", "SUCCESS")
        
        with open(f"{self.output_dir}/ports_discovered.json", 'w') as f:
            json.dump(self.discovered_ports, f, indent=2)
        
        return len(self.discovered_ports) > 0
    
    def parse_nmap_output(self, output):
        """Parse Nmap"""
        for line in output.split('\n'):
            if '/tcp' in line and 'open' in line:
                parts = line.split()
                port = parts[0].split('/')[0]
                service = parts[2] if len(parts) > 2 else 'unknown'
                version = ' '.join(parts[3:]) if len(parts) > 3 else ''
                
                port_info = {
                    'port': port,
                    'protocol': 'tcp',
                    'state': 'open',
                    'service': service,
                    'version': version
                }
                
                self.discovered_ports.append(port_info)
                self.log(f"Porta: {port} | Servi√ßo: {service} {version}", "SUCCESS")
                
                # Detectar web
                web_indicators = ['http', 'https', 'ssl', 'www']
                if any(ind in service.lower() for ind in web_indicators) or port in ['80', '443', '8080', '8443', '8000', '8888', '3000', '5000']:
                    self.web_services.append(port_info)
                    self.log(f"üåê WEB detectado: porta {port}", "DECISION")
    
    # ===== FASE 2: WEB ENUMERATION & CMS DETECTION =====
    
    def phase2_web_enumeration(self):
        """Web enumeration com detec√ß√£o de CMS"""
        if not self.web_services:
            self.log("Nenhum servi√ßo web detectado.", "WARNING")
            return
        
        self.log("="*60, "INFO")
        self.log("FASE 2: AN√ÅLISE WEB & DETEC√á√ÉO DE CMS", "INFO")
        self.log("="*60, "INFO")
        
        for web_service in self.web_services:
            port = web_service['port']
            protocol = 'https' if port in ['443', '8443'] or 'ssl' in web_service.get('service', '').lower() else 'http'
            url = f"{protocol}://{self.target}:{port}"
            
            self.log(f"üîç Analisando {url}", "INFO")
            
            # 1. Detectar e identificar CMS com VERS√ÉO
            self.detect_cms_with_version(url, port)
            
            # 2. Enumerar diret√≥rios
            self.enumerate_directories(url, port)
    
    def detect_cms_with_version(self, url, port):
        """Detecta CMS e sua VERS√ÉO EXATA"""
        self.log(f"üîé Detectando CMS e vers√£o em {url}", "INFO")
        
        # WordPress
        wp_version = self.detect_wordpress_version(url)
        if wp_version:
            self.cms_info[url] = {
                'type': 'WordPress',
                'version': wp_version,
                'port': port
            }
            self.technologies[url] = [f"WordPress {wp_version}"]
            self.log(f"üéØ WordPress {wp_version} DETECTADO!", "SUCCESS")
            return
        
        # Joomla
        joomla_version = self.detect_joomla_version(url)
        if joomla_version:
            self.cms_info[url] = {
                'type': 'Joomla',
                'version': joomla_version,
                'port': port
            }
            self.technologies[url] = [f"Joomla {joomla_version}"]
            self.log(f"üéØ Joomla {joomla_version} DETECTADO!", "SUCCESS")
            return
        
        # Drupal
        drupal_version = self.detect_drupal_version(url)
        if drupal_version:
            self.cms_info[url] = {
                'type': 'Drupal',
                'version': drupal_version,
                'port': port
            }
            self.technologies[url] = [f"Drupal {drupal_version}"]
            self.log(f"üéØ Drupal {drupal_version} DETECTADO!", "SUCCESS")
            return
        
        # Magento
        if self.is_magento(url):
            self.cms_info[url] = {'type': 'Magento', 'version': 'Unknown', 'port': port}
            self.technologies[url] = ['Magento']
            self.log(f"üéØ Magento DETECTADO!", "SUCCESS")
            return
        
        self.log("Nenhum CMS conhecido detectado", "INFO")
    
    def detect_wordpress_version(self, url):
        """Detecta vers√£o EXATA do WordPress"""
        # M√©todo 1: readme.html
        output, code = self.run_command(
            f"curl -s -A '{self.user_agent}' -L -m 10 {url}/readme.html",
            "Verificando readme.html",
            timeout=15
        )
        
        if output:
            # Procurar "Version X.X.X"
            version_match = re.search(r'Version\s+(\d+\.\d+(?:\.\d+)?)', output)
            if version_match:
                return version_match.group(1)
        
        # M√©todo 2: Meta generator
        output, code = self.run_command(
            f"curl -s -A '{self.user_agent}' -L -m 10 {url}/",
            "Verificando meta generator",
            timeout=15
        )
        
        if output:
            version_match = re.search(r'WordPress\s+(\d+\.\d+(?:\.\d+)?)', output)
            if version_match:
                return version_match.group(1)
            
            # Generator tag
            gen_match = re.search(r'content=["\']WordPress\s+(\d+\.\d+(?:\.\d+)?)["\']', output)
            if gen_match:
                return gen_match.group(1)
        
        # M√©todo 3: Verificar se √© WordPress sem vers√£o
        wp_paths = ['/wp-content/', '/wp-includes/', '/wp-admin/']
        for path in wp_paths:
            output, code = self.run_command(
                f"curl -s -A '{self.user_agent}' -I -m 5 {url}{path}",
                f"Verificando {path}",
                timeout=10
            )
            if output and '200' in output:
                return "Unknown"
        
        return None
    
    def detect_joomla_version(self, url):
        """Detecta vers√£o do Joomla"""
        output, code = self.run_command(
            f"curl -s -A '{self.user_agent}' -m 10 {url}/administrator/manifests/files/joomla.xml",
            "Verificando Joomla XML",
            timeout=15
        )
        
        if output:
            version_match = re.search(r'<version>([^<]+)</version>', output)
            if version_match:
                return version_match.group(1)
        
        # Verificar se √© Joomla sem vers√£o
        output, code = self.run_command(
            f"curl -s -A '{self.user_agent}' -L -m 10 {url}/administrator/",
            "Verificando Joomla admin",
            timeout=15
        )
        
        if output and ('joomla' in output.lower() or 'administration login' in output.lower()):
            return "Unknown"
        
        return None
    
    def detect_drupal_version(self, url):
        """Detecta vers√£o do Drupal"""
        output, code = self.run_command(
            f"curl -s -A '{self.user_agent}' -L -m 10 {url}/CHANGELOG.txt",
            "Verificando CHANGELOG.txt",
            timeout=15
        )
        
        if output:
            version_match = re.search(r'Drupal\s+(\d+\.\d+(?:\.\d+)?)', output)
            if version_match:
                return version_match.group(1)
        
        # Verificar meta generator
        output, code = self.run_command(
            f"curl -s -A '{self.user_agent}' -L -m 10 {url}/",
            "Verificando meta Drupal",
            timeout=15
        )
        
        if output and 'Drupal' in output:
            return "Unknown"
        
        return None
    
    def is_magento(self, url):
        """Detecta Magento"""
        output, code = self.run_command(
            f"curl -s -A '{self.user_agent}' -L -m 10 {url}/",
            "Verificando Magento",
            timeout=15
        )
        return output and ('Mage' in output or 'magento' in output.lower())
    
    def enumerate_directories(self, url, port):
        """Enumera diret√≥rios"""
        self.log(f"üìÇ Enumerando diret√≥rios em {url}", "INFO")
        
        wordlist = "/usr/share/wordlists/dirb/common.txt"
        
        if not os.path.exists(wordlist):
            self.log("Wordlist n√£o encontrada!", "WARNING")
            return
        
        if self.check_tool("gobuster"):
            output_file = f"{self.output_dir}/gobuster_port_{port}.txt"
            threads = 50 if self.aggressive else 20
            
            self.run_command(
                f"gobuster dir -u {url} -w {wordlist} -o {output_file} -q -t {threads} -b 404 -a '{self.user_agent}'",
                f"Gobuster - {url}",
                timeout=600
            )
            
            if os.path.exists(output_file):
                self.parse_gobuster_output(output_file, url)
    
    def parse_gobuster_output(self, output_file, url):
        """Parse Gobuster"""
        try:
            with open(output_file, 'r') as f:
                content = f.read()
                
            dirs = re.findall(r'(/.+?)\s+\(Status: (\d+)\)', content)
            
            for path, status in dirs:
                dir_info = {
                    'url': url,
                    'path': path,
                    'status': status,
                    'full_url': f"{url}{path}"
                }
                self.directories.append(dir_info)
                self.log(f"üìÅ {path} (Status: {status})", "SUCCESS")
                
                critical_paths = ['/admin', '/login', '/wp-admin', '/phpmyadmin', 
                                '/administrator', '/backup', '/config', '/.git', 
                                '/upload', '/.env', '/database']
                
                if any(crit in path.lower() for crit in critical_paths):
                    self.log(f"üö® PATH CR√çTICO: {path}", "VULN")
                    self.findings.append({
                        'type': 'critical_path',
                        'severity': 'high',
                        'path': path,
                        'url': f"{url}{path}"
                    })
        except Exception as e:
            self.log(f"Erro ao parsear Gobuster: {e}", "ERROR")
    
    # ===== FASE 3: VULNERABILITY SCANNING (CONDICIONAL) =====
    
    def phase3_vulnerability_scanning(self):
        """Vulnerability scanning baseado em CMS"""
        self.log("="*60, "INFO")
        self.log("FASE 3: VULNERABILITY SCANNING", "INFO")
        self.log("="*60, "INFO")
        
        cms_detected = False
        
        # Para cada CMS detectado
        for url, cms_data in self.cms_info.items():
            cms_detected = True
            cms_type = cms_data['type']
            cms_version = cms_data.get('version', 'Unknown')
            
            self.log(f"CMS: {cms_type} {cms_version}", "INFO")
            
            # WordPress ‚Üí WPScan espec√≠fico
            if cms_type == 'WordPress':
                self.scan_wordpress_plugins(url, cms_version)
            
            # Joomla ‚Üí JoomScan
            elif cms_type == 'Joomla':
                self.scan_joomla(url, cms_version)
            
            # Drupal ‚Üí Droopescan
            elif cms_type == 'Drupal':
                self.scan_drupal(url, cms_version)
            
            # Buscar exploits para o CMS espec√≠fico
            self.search_exploits_for_cms(cms_type, cms_version)
        
        # Se N√ÉO houver CMS ‚Üí Perguntar sobre Nikto
        if not cms_detected:
            self.log("="*60, "WARNING")
            self.log("NENHUM CMS DETECTADO", "WARNING")
            self.log("="*60, "WARNING")
            
            # PERGUNTAR se quer executar Nikto
            if self.ask_user("Nenhum CMS encontrado. Deseja executar Nikto para an√°lise gen√©rica?", "y"):
                for web_service in self.web_services:
                    port = web_service['port']
                    protocol = 'https' if port in ['443', '8443'] else 'http'
                    url = f"{protocol}://{self.target}:{port}"
                    self.scan_nikto(url, port)
            else:
                self.log("Nikto ignorado pelo usu√°rio", "INFO")
        else:
            # CMS detectado - perguntar se AINDA quer Nikto
            if self.ask_user("CMS detectado e scaneado. Deseja executar Nikto tamb√©m?", "n"):
                for web_service in self.web_services:
                    port = web_service['port']
                    protocol = 'https' if port in ['443', '8443'] else 'http'
                    url = f"{protocol}://{self.target}:{port}"
                    self.scan_nikto(url, port)
        
        # Nuclei (opcional)
        if self.check_tool("nuclei"):
            if self.ask_user("Executar Nuclei scan?", "n"):
                self.scan_nuclei()
    
    def scan_wordpress_plugins(self, url, version):
        """WPScan focado em PLUGINS"""
        if not self.check_tool("wpscan"):
            self.log("‚ö†Ô∏è  WPScan n√£o instalado!", "WARNING")
            return
        
        self.log("="*60, "INFO")
        self.log(f"üéØ WPSCAN - FOCO EM PLUGINS", "INFO")
        self.log(f"WordPress vers√£o: {version}", "INFO")
        self.log("="*60, "INFO")
        
        output_file = f"{self.output_dir}/wpscan_plugins.json"
        output_txt = f"{self.output_dir}/wpscan_plugins.txt"
        
        # Comando EXATO que voc√™ pediu + aggressive
        command = f"wpscan --url {url} --enumerate p --plugins-detection aggressive --user-agent '{self.user_agent}' --format json --output {output_file} --disable-tls-checks"
        
        self.log("Executando WPScan para plugins...", "INFO")
        output, code = self.run_command(command, "WPScan Plugins", timeout=900)
        
        # Tamb√©m em TXT
        self.run_command(
            f"wpscan --url {url} --enumerate p --plugins-detection aggressive --user-agent '{self.user_agent}' --output {output_txt} --disable-tls-checks",
            "WPScan TXT",
            timeout=900
        )
        
        if os.path.exists(output_file):
            self.parse_wpscan_plugins(output_file, url, version)
    
    def parse_wpscan_plugins(self, output_file, url, wp_version):
        """Parse WPScan focado em plugins"""
        try:
            with open(output_file, 'r') as f:
                data = json.load(f)
            
            self.log("="*60, "SUCCESS")
            self.log("RESULTADOS WPSCAN", "SUCCESS")
            self.log("="*60, "SUCCESS")
            
            # Plugins
            plugins = data.get('plugins', {})
            if plugins:
                self.log(f"üîå {len(plugins)} PLUGINS ENCONTRADOS", "INFO")
                
                vuln_count = 0
                for plugin_slug, plugin_data in plugins.items():
                    plugin_version = plugin_data.get('version', {}).get('number', 'Unknown')
                    
                    self.plugins_found.append({
                        'name': plugin_slug,
                        'version': plugin_version,
                        'url': url
                    })
                    
                    plugin_vulns = plugin_data.get('vulnerabilities', [])
                    
                    if plugin_vulns:
                        vuln_count += 1
                        self.log(f"  üö® {plugin_slug} v{plugin_version} - {len(plugin_vulns)} VULNERABILIDADES!", "VULN")
                        
                        for vuln in plugin_vulns:
                            self.vulnerabilities.append({
                                'type': 'wordpress_plugin',
                                'url': url,
                                'plugin': plugin_slug,
                                'plugin_version': plugin_version,
                                'title': vuln.get('title', 'Unknown'),
                                'severity': 'high',
                                'fixed_in': vuln.get('fixed_in'),
                                'references': vuln.get('references', {})
                            })
                            self.log(f"    üí• {vuln.get('title')}", "VULN")
                            
                            refs = vuln.get('references', {})
                            if 'cve' in refs:
                                for cve in refs['cve']:
                                    self.log(f"      üîó {cve}", "INFO")
                    else:
                        self.log(f"  ‚úÖ {plugin_slug} v{plugin_version}", "SUCCESS")
                
                if vuln_count > 0:
                    self.log(f"‚ö†Ô∏è  {vuln_count} plugins VULNER√ÅVEIS!", "VULN")
            
            # Salvar
            if self.plugins_found:
                with open(f"{self.output_dir}/wordpress_plugins.json", 'w') as f:
                    json.dump(self.plugins_found, f, indent=2)
            
        except Exception as e:
            self.log(f"Erro ao parsear WPScan: {e}", "ERROR")
    
    def scan_joomla(self, url, version):
        """Scan Joomla"""
        self.log(f"üéØ Joomla {version} detectado", "INFO")
        
        if self.check_tool("joomscan"):
            output_file = f"{self.output_dir}/joomscan_result.txt"
            self.run_command(
                f"joomscan -u {url} > {output_file}",
                "JoomScan",
                timeout=300
            )
    
    def scan_drupal(self, url, version):
        """Scan Drupal"""
        self.log(f"üéØ Drupal {version} detectado", "INFO")
        
        if self.check_tool("droopescan"):
            output_file = f"{self.output_dir}/droopescan_result.txt"
            self.run_command(
                f"droopescan scan drupal -u {url} > {output_file}",
                "Droopescan",
                timeout=300
            )
    
    def scan_nikto(self, url, port):
        """Nikto scan"""
        if not self.check_tool("nikto"):
            self.log("Nikto n√£o dispon√≠vel", "WARNING")
            return
        
        self.nikto_executed = True  # Marcar que foi executado
        self.log(f"üîç Executando Nikto em {url}", "INFO")
        
        output_file = f"{self.output_dir}/nikto_port_{port}.txt"
        self.run_command(
            f"nikto -h {url} -useragent '{self.user_agent}' -output {output_file} -Format txt",
            f"Nikto - {url}",
            timeout=600
        )
        
        if os.path.exists(output_file):
            self.parse_nikto_output(output_file, url)
            self.log(f"Nikto salvo em: {output_file}", "SUCCESS")
    
    def parse_nikto_output(self, output_file, url):
        """Parse do output do Nikto"""
        try:
            with open(output_file, 'r') as f:
                content = f.read()
            
            vuln_keywords = ['OSVDB', 'CVE', 'vulnerable', 'outdated', 'deprecated', 'vulnerability']
            
            for line in content.split('\n'):
                if any(keyword.lower() in line.lower() for keyword in vuln_keywords):
                    self.vulnerabilities.append({
                        'type': 'nikto',
                        'url': url,
                        'description': line.strip(),
                        'severity': 'medium'
                    })
                    
        except Exception as e:
            self.log(f"Erro ao parsear Nikto: {e}", "ERROR")
    
    def scan_nuclei(self):
        """Nuclei scan"""
        self.log("üöÄ Nuclei scan...", "INFO")
        
        output_file = f"{self.output_dir}/nuclei_results.json"
        self.run_command(
            f"nuclei -u {self.target} -json -o {output_file} -severity critical,high,medium -silent",
            "Nuclei",
            timeout=900
        )
    
    # ===== FASE 4: EXPLOIT SEARCH =====
    
    def search_exploits_for_cms(self, cms_type, cms_version):
        """Busca exploits para CMS espec√≠fico"""
        self.log("="*60, "INFO")
        self.log(f"BUSCANDO EXPLOITS: {cms_type} {cms_version}", "EXPLOIT")
        self.log("="*60, "INFO")
        
        search_term = f"{cms_type} {cms_version}".strip()
        
        # 1. SearchSploit
        exploits = self.search_searchsploit(search_term)
        
        # 2. Sugest√µes de pesquisa
        self.suggest_online_searches(cms_type, cms_version, exploits)
    
    def search_searchsploit(self, search_term):
        """SearchSploit"""
        if not self.check_tool("searchsploit"):
            self.log("SearchSploit n√£o dispon√≠vel", "WARNING")
            return []
        
        self.log(f"üîé SearchSploit: {search_term}", "INFO")
        
        output, code = self.run_command(
            f"searchsploit '{search_term}' --json",
            f"SearchSploit - {search_term}",
            timeout=30
        )
        
        exploits = []
        
        if output:
            try:
                data = json.loads(output)
                results = data.get('RESULTS_EXPLOIT', [])
                
                if results:
                    self.log(f"üí£ {len(results)} EXPLOITS ENCONTRADOS!", "EXPLOIT")
                    
                    for i, exploit in enumerate(results[:10]):
                        title = exploit.get('Title', 'Unknown')
                        path = exploit.get('Path', '')
                        
                        exploits.append({
                            'title': title,
                            'path': path,
                            'source': 'SearchSploit'
                        })
                        
                        self.exploits_found.append({
                            'cms': search_term,
                            'title': title,
                            'path': path,
                            'source': 'SearchSploit'
                        })
                        
                        self.log(f"  {i+1}. {title}", "EXPLOIT")
                    
                    # Salvar exploits
                    exploit_file = f"{self.output_dir}/exploits_{search_term.replace(' ', '_')}.json"
                    with open(exploit_file, 'w') as f:
                        json.dump(results[:10], f, indent=2)
                    
                    self.log(f"Exploits salvos em: {exploit_file}", "SUCCESS")
                else:
                    self.log("Nenhum exploit encontrado no SearchSploit", "INFO")
            except Exception as e:
                self.log(f"Erro ao parsear SearchSploit: {e}", "ERROR")
        
        return exploits
    
    def suggest_online_searches(self, cms_type, cms_version, local_exploits):
        """Sugest√µes de pesquisa online"""
        self.log("="*60, "INFO")
        self.log("SUGEST√ïES DE PESQUISA ONLINE", "INFO")
        self.log("="*60, "INFO")
        
        search_queries = []
        
        # Google
        google_queries = [
            f"{cms_type} {cms_version} exploit",
            f"{cms_type} {cms_version} CVE",
            f"{cms_type} {cms_version} vulnerability",
            f"{cms_type} {cms_version} RCE"
        ]
        
        # GitHub
        github_queries = [
            f"{cms_type} {cms_version} exploit site:github.com",
            f"{cms_type} {cms_version} poc site:github.com"
        ]
        
        # Exploit-DB
        exploitdb_queries = [
            f"{cms_type} {cms_version} site:exploit-db.com"
        ]
        
        self.log("üìç PESQUISE NO GOOGLE:", "INFO")
        for query in google_queries:
            url = f"https://www.google.com/search?q={query.replace(' ', '+')}"
            self.log(f"  ‚Ä¢ {query}", "INFO")
            search_queries.append({'platform': 'Google', 'query': query, 'url': url})
        
        print()
        self.log("üìç PESQUISE NO GITHUB:", "INFO")
        for query in github_queries:
            url = f"https://github.com/search?q={query.replace(' ', '+')}&type=repositories"
            self.log(f"  ‚Ä¢ {query}", "INFO")
            search_queries.append({'platform': 'GitHub', 'query': query, 'url': url})
        
        print()
        self.log("üìç PESQUISE NO EXPLOIT-DB:", "INFO")
        for query in exploitdb_queries:
            url = f"https://www.exploit-db.com/search?q={cms_type}+{cms_version}"
            self.log(f"  ‚Ä¢ {query}", "INFO")
            search_queries.append({'platform': 'Exploit-DB', 'query': query, 'url': url})
        
        # Salvar sugest√µes
        suggestions_file = f"{self.output_dir}/search_suggestions.json"
        with open(suggestions_file, 'w') as f:
            json.dump({
                'cms': cms_type,
                'version': cms_version,
                'local_exploits': len(local_exploits),
                'search_queries': search_queries
            }, f, indent=2)
        
        self.log(f"\nüí° Sugest√µes salvas em: {suggestions_file}", "SUCCESS")
    
    # ===== FASE 5: REPORT =====
    
    def phase5_generate_report(self):
        """Relat√≥rio final"""
        self.log("="*60, "INFO")
        self.log("FASE 5: GERANDO RELAT√ìRIO", "INFO")
        self.log("="*60, "INFO")
        
        report = {
            'target': self.target,
            'scan_date': datetime.now().isoformat(),
            'nikto_executed': self.nikto_executed,  # NOVO
            'summary': {
                'ports_discovered': len(self.discovered_ports),
                'web_services': len(self.web_services),
                'cms_detected': len(self.cms_info),
                'directories_found': len(self.directories),
                'vulnerabilities_found': len(self.vulnerabilities),
                'plugins_found': len(self.plugins_found),
                'exploits_found': len(self.exploits_found),
                'findings': len(self.findings)
            },
            'ports': self.discovered_ports,
            'cms_info': self.cms_info,
            'technologies': self.technologies,
            'plugins': self.plugins_found,
            'directories': self.directories[:100],
            'vulnerabilities': self.vulnerabilities,
            'exploits': self.exploits_found,
            'findings': self.findings
        }
        
        report_file = f"{self.output_dir}/FINAL_REPORT.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        self.log(f"üìÑ JSON: {report_file}", "SUCCESS")
        
        self.generate_html_report(report)
        self.print_summary(report)
    
    def generate_html_report(self, report):
        """HTML Report com p√°gina de exploits e sem Nikto se n√£o executado"""
        html_file = f"{self.output_dir}/FINAL_REPORT.html"
        
        # CMS Info
        cms_html = ""
        if report['cms_info']:
            cms_html = """
            <div class="section">
                <h2>üéØ CMS Detectados</h2>
                <div class="info-box">
            """
            for url, cms_data in report['cms_info'].items():
                cms_type = cms_data['type']
                cms_version = cms_data.get('version', 'Unknown')
                cms_html += f"""
                    <div class="cms-item">
                        <strong>{cms_type}</strong> <span class="version-badge">{cms_version}</span>
                        <br><small>URL: {url}</small>
                    </div>
                """
            cms_html += "</div></div>"
        
        # Plugins
        plugins_html = ""
        if report['plugins']:
            plugins_html = """
            <div class="section">
                <h2>üîå Plugins WordPress</h2>
                <table>
                    <tr>
                        <th>Nome</th>
                        <th>Vers√£o</th>
                        <th>Status</th>
                    </tr>
            """
            
            # Verificar quais plugins t√™m vulnerabilidades
            vuln_plugins = set()
            for vuln in report['vulnerabilities']:
                if vuln.get('type') == 'wordpress_plugin':
                    vuln_plugins.add(vuln.get('plugin'))
            
            for plugin in report['plugins']:
                is_vuln = plugin['name'] in vuln_plugins
                status_class = 'status-vulnerable' if is_vuln else 'status-ok'
                status_text = 'üö® VULNER√ÅVEL' if is_vuln else '‚úÖ OK'
                
                plugins_html += f"""
                    <tr class="{status_class}">
                        <td><strong>{plugin['name']}</strong></td>
                        <td>{plugin['version']}</td>
                        <td><span class="{status_class}">{status_text}</span></td>
                    </tr>
                """
            plugins_html += "</table></div>"
        
        # EXPLOITS - NOVA P√ÅGINA COMPLETA
        exploits_html = ""
        if report['exploits']:
            exploits_html = """
            <div class="section exploits-section">
                <h2>üí£ Exploits Encontrados</h2>
                <p class="section-description">Exploits dispon√≠veis localmente via SearchSploit</p>
            """
            
            # Agrupar exploits por CMS
            exploits_by_cms = {}
            for exploit in report['exploits']:
                cms = exploit.get('cms', 'Unknown')
                if cms not in exploits_by_cms:
                    exploits_by_cms[cms] = []
                exploits_by_cms[cms].append(exploit)
            
            for cms, exploits in exploits_by_cms.items():
                exploits_html += f"""
                <div class="exploit-group">
                    <h3>üì¶ {cms} ({len(exploits)} exploits)</h3>
                """
                
                for i, exploit in enumerate(exploits, 1):
                    title = exploit.get('title', 'Unknown')
                    path = exploit.get('path', '')
                    
                    # Extrair CVE do t√≠tulo se existir
                    cve_match = re.search(r'(CVE-\d{4}-\d+)', title)
                    cve_badge = ""
                    if cve_match:
                        cve = cve_match.group(1)
                        cve_url = f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve}"
                        cve_badge = f'<a href="{cve_url}" target="_blank" class="cve-badge">{cve}</a>'
                    
                    exploits_html += f"""
                    <div class="exploit-item">
                        <div class="exploit-number">#{i}</div>
                        <div class="exploit-content">
                            <div class="exploit-title">{title}</div>
                            {cve_badge}
                            <div class="exploit-path">
                                <small>üìÅ Path: <code>{path}</code></small>
                            </div>
                            <div class="exploit-actions">
                                <button onclick="copyToClipboard('searchsploit -m {path}')" class="btn-copy">
                                    üìã Copiar comando
                                </button>
                            </div>
                        </div>
                    </div>
                    """
                
                exploits_html += "</div>"
            
            # Adicionar sugest√µes de pesquisa online
            suggestions_file = f"{self.output_dir}/search_suggestions.json"
            if os.path.exists(suggestions_file):
                try:
                    with open(suggestions_file, 'r') as f:
                        suggestions = json.load(f)
                    
                    exploits_html += """
                    <div class="search-suggestions">
                        <h3>üîç Pesquisar Mais Exploits Online</h3>
                        <p>Use estas buscas para encontrar mais exploits e POCs:</p>
                    """
                    
                    queries = suggestions.get('search_queries', [])
                    for query in queries:
                        platform = query.get('platform', 'Unknown')
                        search_text = query.get('query', '')
                        url = query.get('url', '#')
                        
                        icon = "üîç"
                        if platform == "GitHub":
                            icon = "üíª"
                        elif platform == "Exploit-DB":
                            icon = "üí£"
                        
                        exploits_html += f"""
                        <div class="search-item">
                            <a href="{url}" target="_blank" class="search-link">
                                {icon} {platform}: {search_text}
                            </a>
                        </div>
                        """
                    
                    exploits_html += "</div>"
                except:
                    pass
            
            exploits_html += "</div>"
        
        # Vulnerabilidades com CVE destacado
        vuln_html = ""
        if report['vulnerabilities']:
            vuln_html = """
            <div class="section">
                <h2>üö® Vulnerabilidades Cr√≠ticas</h2>
            """
            
            # Agrupar por tipo
            vuln_types = {}
            for vuln in report['vulnerabilities']:
                vtype = vuln.get('type', 'unknown')
                if vtype not in vuln_types:
                    vuln_types[vtype] = []
                vuln_types[vtype].append(vuln)
            
            for vtype, vulns in vuln_types.items():
                # Pular vulnerabilidades do Nikto se n√£o foi executado
                if vtype == 'nikto' and not report.get('nikto_executed', False):
                    continue
                
                vuln_html += f"""
                <div class="vuln-group">
                    <h3>{vtype.replace('_', ' ').title()} ({len(vulns)})</h3>
                """
                
                for vuln in vulns:
                    severity = vuln.get('severity', 'medium')
                    title = vuln.get('title', vuln.get('name', 'Unknown'))
                    description = vuln.get('description', '')
                    plugin = vuln.get('plugin', '')
                    theme = vuln.get('theme', '')
                    fixed_in = vuln.get('fixed_in', '')
                    
                    # Extrair CVEs das refer√™ncias
                    cve_badges = ""
                    refs = vuln.get('references', {})
                    if isinstance(refs, dict) and 'cve' in refs:
                        cves = refs['cve'] if isinstance(refs['cve'], list) else [refs['cve']]
                        for cve in cves:
                            cve_url = f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve}"
                            cve_badges += f'<a href="{cve_url}" target="_blank" class="cve-badge">{cve}</a> '
                    
                    vuln_html += f"""
                    <div class="vuln severity-{severity}">
                        <div class="vuln-header">
                            <span class="severity-badge severity-{severity}">{severity.upper()}</span>
                            <strong class="vuln-title">{title}</strong>
                        </div>
                        {f'<div class="vuln-plugin">Plugin: <strong>{plugin}</strong></div>' if plugin else ''}
                        {f'<div class="vuln-theme">Theme: <strong>{theme}</strong></div>' if theme else ''}
                        {f'<div class="vuln-description">{description}</div>' if description else ''}
                        {f'<div class="vuln-fixed">‚úÖ Fixed in: <strong>{fixed_in}</strong></div>' if fixed_in else ''}
                        {f'<div class="vuln-cves">{cve_badges}</div>' if cve_badges else ''}
                    </div>
                    """
                
                vuln_html += "</div>"
            
            vuln_html += "</div>"
        
        # Portas
        ports_html = ""
        if report['ports']:
            for port in report['ports']:
                ports_html += f"""
                <tr>
                    <td><strong>{port['port']}</strong></td>
                    <td>{port.get('service', 'unknown')}</td>
                    <td>{port.get('version', '')}</td>
                </tr>
                """
        
        # HTML completo
        html_content = f"""
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pentest Report - {self.target}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            line-height: 1.6;
        }}
        
        .container {{
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }}
        
        h1 {{
            color: #2c3e50;
            border-bottom: 4px solid #667eea;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2.5em;
            display: flex;
            align-items: center;
            gap: 15px;
        }}
        
        h2 {{
            color: #34495e;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-left: 5px solid #667eea;
            padding-left: 15px;
        }}
        
        h3 {{
            color: #555;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }}
        
        .header-info {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }}
        
        .header-info p {{
            margin: 8px 0;
            color: #555;
        }}
        
        .summary {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }}
        
        .stat {{
            text-align: center;
            padding: 15px;
        }}
        
        .stat-number {{
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }}
        
        .stat-label {{
            font-size: 0.9em;
            opacity: 0.95;
            text-transform: uppercase;
            letter-spacing: 1px;
        }}
        
        .section {{
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 8px;
        }}
        
        .section-description {{
            color: #666;
            font-style: italic;
            margin-bottom: 20px;
        }}
        
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }}
        
        th {{
            background: #34495e;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 0.5px;
        }}
        
        td {{
            padding: 12px 15px;
            border-bottom: 1px solid #ecf0f1;
        }}
        
        tr:hover {{
            background: #f8f9fa;
        }}
        
        tr.status-vulnerable {{
            background: #fff5f5;
        }}
        
        tr.status-vulnerable:hover {{
            background: #ffe5e5;
        }}
        
        .status-vulnerable {{
            color: #dc3545;
            font-weight: bold;
        }}
        
        .status-ok {{
            color: #28a745;
        }}
        
        .info-box {{
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }}
        
        .cms-item {{
            padding: 15px;
            margin: 10px 0;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }}
        
        .version-badge {{
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
        }}
        
        /* EXPLOITS SECTION */
        .exploits-section {{
            background: #fff8e1;
            border: 2px solid #ffc107;
        }}
        
        .exploit-group {{
            margin: 25px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #ff6b6b;
        }}
        
        .exploit-item {{
            display: flex;
            gap: 15px;
            padding: 15px;
            margin: 10px 0;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }}
        
        .exploit-item:hover {{
            background: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }}
        
        .exploit-number {{
            background: #ff6b6b;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }}
        
        .exploit-content {{
            flex: 1;
        }}
        
        .exploit-title {{
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
        }}
        
        .exploit-path {{
            margin: 8px 0;
            color: #666;
        }}
        
        .exploit-path code {{
            background: #2c3e50;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
        }}
        
        .exploit-actions {{
            margin-top: 10px;
        }}
        
        .btn-copy {{
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }}
        
        .btn-copy:hover {{
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }}
        
        .cve-badge {{
            display: inline-block;
            background: #dc3545;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
            text-decoration: none;
            margin: 4px 4px 4px 0;
            transition: all 0.3s ease;
        }}
        
        .cve-badge:hover {{
            background: #c82333;
            transform: scale(1.05);
        }}
        
        .search-suggestions {{
            margin-top: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border: 2px dashed #667eea;
        }}
        
        .search-item {{
            margin: 10px 0;
        }}
        
        .search-link {{
            display: block;
            padding: 12px 15px;
            background: #f8f9fa;
            border-radius: 6px;
            color: #667eea;
            text-decoration: none;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }}
        
        .search-link:hover {{
            background: #667eea;
            color: white;
            transform: translateX(5px);
        }}
        
        /* VULNERABILIDADES */
        .vuln-group {{
            margin: 25px 0;
        }}
        
        .vuln {{
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 5px solid #ffc107;
            background: #fff3cd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }}
        
        .vuln.severity-high {{
            background: #f8d7da;
            border-left-color: #dc3545;
        }}
        
        .vuln.severity-critical {{
            background: #f8d7da;
            border-left-color: #721c24;
            border-width: 0 0 0 8px;
        }}
        
        .vuln.severity-medium {{
            background: #fff3cd;
            border-left-color: #ffc107;
        }}
        
        .vuln.severity-low {{
            background: #d1ecf1;
            border-left-color: #17a2b8;
        }}
        
        .vuln-header {{
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }}
        
        .severity-badge {{
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }}
        
        .severity-badge.severity-critical {{
            background: #721c24;
            color: white;
        }}
        
        .severity-badge.severity-high {{
            background: #dc3545;
            color: white;
        }}
        
        .severity-badge.severity-medium {{
            background: #ffc107;
            color: #333;
        }}
        
        .severity-badge.severity-low {{
            background: #17a2b8;
            color: white;
        }}
        
        .vuln-title {{
            font-size: 1.1em;
            color: #2c3e50;
        }}
        
        .vuln-plugin, .vuln-theme, .vuln-description, .vuln-fixed {{
            margin: 8px 0;
            color: #555;
        }}
        
        .vuln-cves {{
            margin-top: 12px;
        }}
        
        .alert {{
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 5px solid;
        }}
        
        .alert-danger {{
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }}
        
        .alert-success {{
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }}
        
        .footer {{
            margin-top: 60px;
            padding-top: 30px;
            border-top: 2px solid #ecf0f1;
            text-align: center;
            color: #7f8c8d;
        }}
        
        .footer p {{
            margin: 10px 0;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ Autonomous Pentest Report v4.0</h1>
        
        <div class="header-info">
            <p><strong>üéØ Target:</strong> {self.target}</p>
            <p><strong>üìÖ Data do Scan:</strong> {report['scan_date']}</p>
            <p><strong>ü§ñ Scanner:</strong> Pentest Robot v4.0 - Interactive & Smart</p>
            <p><strong>üìÇ Output:</strong> {self.output_dir}</p>
        </div>
        
        <div class="summary">
            <div class="stat">
                <div class="stat-number">{report['summary']['ports_discovered']}</div>
                <div class="stat-label">Portas</div>
            </div>
            <div class="stat">
                <div class="stat-number">{report['summary']['cms_detected']}</div>
                <div class="stat-label">CMS</div>
            </div>
            <div class="stat">
                <div class="stat-number">{report['summary']['plugins_found']}</div>
                <div class="stat-label">Plugins</div>
            </div>
            <div class="stat">
                <div class="stat-number">{report['summary']['exploits_found']}</div>
                <div class="stat-label">Exploits</div>
            </div>
            <div class="stat">
                <div class="stat-number">{report['summary']['vulnerabilities_found']}</div>
                <div class="stat-label">Vulnerabilidades</div>
            </div>
        </div>
        
        {f'<div class="alert alert-danger"><strong>‚ö†Ô∏è CR√çTICO:</strong> {report["summary"]["vulnerabilities_found"]} vulnerabilidades encontradas! Revise imediatamente.</div>' if report['summary']['vulnerabilities_found'] > 0 else '<div class="alert alert-success"><strong>‚úÖ Nenhuma vulnerabilidade cr√≠tica detectada automaticamente.</strong></div>'}
        
        <h2>üîì Portas Abertas</h2>
        <table>
            <tr>
                <th>Porta</th>
                <th>Servi√ßo</th>
                <th>Vers√£o</th>
            </tr>
            {ports_html}
        </table>
        
        {cms_html}
        {plugins_html}
        {exploits_html}
        {vuln_html}
        
        <div class="footer">
            <p><strong>Relat√≥rio gerado por Autonomous Pentest Robot v4.0</strong></p>
            <p>‚ö†Ô∏è Este √© um scan automatizado. Sempre realize verifica√ß√£o manual adicional.</p>
            <p>üìß Para d√∫vidas ou suporte, consulte a documenta√ß√£o do projeto.</p>
        </div>
    </div>
    
    <script>
        function copyToClipboard(text) {{
            navigator.clipboard.writeText(text).then(() => {{
                alert('‚úÖ Comando copiado: ' + text);
            }}).catch(err => {{
                console.error('Erro ao copiar:', err);
            }});
        }}
    </script>
</body>
</html>
"""
        
        with open(html_file, 'w') as f:
            f.write(html_content)
        
        self.log(f"üìÑ HTML: {html_file}", "SUCCESS")
    
    def print_summary(self, report):
        """Resumo"""
        print(f"\n{Colors.GREEN}{'='*70}{Colors.ENDC}")
        print(f"{Colors.GREEN}{Colors.BOLD}üéâ SCAN COMPLETO üéâ{Colors.ENDC}")
        print(f"{Colors.GREEN}{'='*70}{Colors.ENDC}\n")
        
        print(f"{Colors.CYAN}üìä RESULTADOS:{Colors.ENDC}")
        print(f"   üéØ CMS: {Colors.YELLOW}{report['summary']['cms_detected']}{Colors.ENDC}")
        print(f"   üîå Plugins: {Colors.YELLOW}{report['summary']['plugins_found']}{Colors.ENDC}")
        print(f"   üí£ Exploits: {Colors.YELLOW}{report['summary']['exploits_found']}{Colors.ENDC}")
        print(f"   üö® Vulnerabilidades: {Colors.RED}{report['summary']['vulnerabilities_found']}{Colors.ENDC}\n")
        
        print(f"{Colors.CYAN}üìÅ ARQUIVOS:{Colors.ENDC}")
        print(f"   üìÑ {self.output_dir}/FINAL_REPORT.html")
        print(f"   üìÑ {self.output_dir}/FINAL_REPORT.json")
        if os.path.exists(f"{self.output_dir}/search_suggestions.json"):
            print(f"   üîç {self.output_dir}/search_suggestions.json")
        print()
    
    def run(self):
        """Execu√ß√£o"""
        self.print_banner()
        start_time = time.time()
        
        try:
            if not self.phase1_port_discovery():
                return
            
            self.phase2_web_enumeration()
            self.phase3_vulnerability_scanning()
            self.phase5_generate_report()
            
        except KeyboardInterrupt:
            self.log("\n‚ö†Ô∏è  Interrompido", "WARNING")
        except Exception as e:
            self.log(f"‚ùå Erro: {e}", "ERROR")
            import traceback
            traceback.print_exc()
        finally:
            duration = time.time() - start_time
            m, s = int(duration // 60), int(duration % 60)
            self.log(f"‚è±Ô∏è  Tempo: {m}m {s}s", "INFO")

def main():
    parser = argparse.ArgumentParser(
        description='ü§ñ Pentest Robot v4.0 - Interactive & Smart'
    )
    
    parser.add_argument('-t', '--target', required=True, help='Target')
    parser.add_argument('-o', '--output', default=None, help='Output directory (default: scan_TARGET_TIMESTAMP)')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet')
    parser.add_argument('-a', '--aggressive', action='store_true', help='Aggressive')
    parser.add_argument('--no-interactive', action='store_true', help='Disable interactive mode')
    
    args = parser.parse_args()
    
    robot = PentestRobot(
        target=args.target,
        output_dir=args.output,
        verbose=not args.quiet,
        aggressive=args.aggressive,
        interactive=not args.no_interactive
    )
    
    robot.run()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Colors.RED}Interrompido{Colors.ENDC}")
        sys.exit(1)
